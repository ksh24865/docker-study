# docker-study
## 1. 컨테이너 기술

* 리눅스 컨테이너 (LinuX Containers,LXC)
  * 단일 컨트롤 호스트 상에서 여러개의 고립된 리눅스 시스템 (컨테이너)들을 실행하기 위한 운영 시스템 레벨 가상화 방법
  * 시스템의 나머지 부분과 격리된 프로세스 세트
    * 프로세스를 실행하는 데 필요한 모든 파일은 고유한 이미지에서 제공되므로, Linux 컨테이너는 개발 단계에서 테스트, 프로덕션에 이르기까지 이식성과 일관성을 유지
    * 테스트 환경을 복제하는 개발 파이프라인보다 훨씬 더 빠른 배포를 실현
* 컨테이너를 사용해야 하는 이유
  * 서버 환경을 재구축하는 부가적인 작업 없이 개발 당시의 환경(라이브러리, 종속성 및 파일)을 로컬에서 애뮬레이션할 수 있다.
  * 큰 수정 없이 어느 환경에서든 애플리케이션이 작동되도록 배포할 수 있다.
* 컨테이너 vs VM
  * 가상화
    * `가상화는 단일 하드웨어 시스템에서 여러 운영 체제(Windows 또는 Linux)가 동시에 실행`될 수 있도록 한다.
    * 가상화는 하이퍼바이저를 사용하여 하드웨어를 에뮬레이션하고 이를 통해 여러 운영 체제를 동시에 실행 -> 고코스트
  * 컨테이너
    * `컨테이너는 동일한 운영 체제 커널을 다른 컨테이너와 공유`하고 시스템의 나머지 부분으로부터 애플리케이션 프로세스를 격리한다.
      *  Linux 컨테이너는 이식성이 매우 뛰어나지만 기본 시스템과 호환되어야 한다.
      * ex) RM Linux 시스템은 ARM Linux 컨테이너를 실행하고, x86 Linux 시스템은 x86 Linux 컨테이너를 실행하고, x86 Windows 시스템은 x86 Windows 컨테이너를 실행
    *  운영 체제에서 기본으로 실행되고 모든 컨테이너 전체에서 운영 체제를 공유하므로 애플리케이션과 서비스를 가볍게 유지할 수 있으며 빠른 속도로 동시에 실행
    * 실행 중인 Linux 컨테이너는 가상 머신보다 리소스를 적게 사용하고 표준 인터페이스(시작, 중지, 환경 변수 등)를 사용하며 애플리케이션 격리를 유지할 뿐 아니라 대규모 애플리케이션(여러 컨테이너)의 일부로 더 쉽게 관리할 수 있다.
  ![image (24)](https://user-images.githubusercontent.com/55729930/102783361-25264d80-43de-11eb-8421-6f70a1a0e167.png)
  

## 2. OCI ( OPEN CONTAINER INITIATIVE )

* OCI
  * 컨테이너 포맷과 런타임에 대한 개방형 업계 표준을 만들기 위한 목적으로 Linux Foundation 의 지원으로 구성된 오픈 거버넌스 조직 (프로젝트)
  * OCI 표준 컨테이너가 만족해야할 5가지 원칙
    |원칙|내용|
    |----|----|
    |표준 동작<br/>(Standard Operations)| • 표준 컨테이너 도구들을 이용해서 컨테이너의 생성, 시작, 정지가 가능해야 함 <br/> • 표준 파일 시스템 도구를 통해서 컨테이너의 스냅샷과 복사가 가능해야 함 <br/> • 표준 네트워크 도구들을 통해서 컨테이너의 업로드와 다운로드가 가능해야 함|
    |내용 중립성<br/>(Content-agnostic)|• 표준 컨테이너는 컨테이너가 담고 있는 애플리케이션의 종류에 상관없이 표준 동작들이 동일하게 동작해야 함|
    |인프라 중립성<br/>(Infrastructure-agnostic)|• 표준 컨테이너는 OCI 지원 인프라라면 종류에 상관없이 컨테이너 실행이 가능해야 함|
    |자동화를 위한 설계<br/>(Designed for Automation)|• 표준 컨테이너는 컨테이너 내용과 인프라 종류에 상관없이 동일한 표준 동작을 지원하기
때문에 자동화가 용이함|
    |산업 수준의 배포<br/>(Industrygrade delivery)|•표준 컨테이너는 기업 규모에 상관없이 산업 수준의 배포가 가능해야 함|
    
* OCI 구성 요소 및 특징
  * OCI를 포함한 리눅스 파운데이션의 표준들은 소스코드처럼 github을 통해 관리되고 있다.
  * OCI 표준의 주요 구성요소
    |구성요소|내용|URL|
    |----|--|---|
    |image-spec|컨테이너 이미지 디스크 포맷|https://github.com/opencontainers/image-spec|
    |image-tools|OCI 이미지 명세에 따라 동작하는 도구 모음|https://github.com/opencontainers/image-tools|
    |runtime-spec|컨테이너의 설정 방법, 실행 환경, 라이프사이클을 명시|https://github.com/opencontainers/runtime-spec|
    |runtime-tools|OCI 런타임 명세에 따라 동작하는 도구 모음|https://github.com/opencontainers/runtime-tools|
    |runc|OCI 표준에 따라 컨테이너를 생성하고 실행할 수 있는 명령형 도구|https://github.com/opencontainers/runc|
    |go-digest|컨테이너 생태계에서 광범위하게 활용될 수 있는 공통 다이제스트(digest) 패키지|https://github.com/opencontainers/go-digest
    |selinux|컨테이너에 범용적으로 적용될 있는 SELinux 설정|https://github.com/opencontainers/selinux|
    



## 3. Docker
* Docker
  * Linux 컨테이너를 만들고 사용할 수 있도록 하는 컨테이너화 기술
  * Docker를 사용하면 컨테이너를 매우 가벼운 모듈식 가상 머신처럼 다룰 수 있다.
  * 컨테이너를 구축, 배포, 복사하고 한 환경에서 다른 환경으로 이동하는 등 유연하게 사용할 수 있어, 애플리케이션을 클라우드에 최적화하도록 지원한다.
* Docker 컨테이너의 이점
  * 모듈성
    * Docker의 컨테이너화 접근 방식은 전체 애플리케이션을 분해할 필요 없이 애플리케이션의 일부를 분해하고, 업데이트 또는 복구하는 능력에 집중되어 있다.
  * 계층 및 이미지 버전 제어
    * Docker 이미지 파일은 일련의 계층으로 이루어져 있으며 이 계층들은 단일 이미지로 결합된다.
    * 이미지가 변경될 때 계층이 생성되고, 사용자가 실행 또는 복사와 같은 명령을 지정할 때마다 새 계층이 생성
    * Docker는 새로운 컨테이너를 구축할 때 이러한 계층을 재사용하므로 구축 프로세스가 훨씬 더 빨라진다.
    * 중간 변경 사항이 이미지 사이에서 공유되므로 속도, 규모, 효율성이 더 개선
    * 계층화에는 버전 관리가 내재되어 변경 사항이 발생 시 로그가 적용되므로 컨테이너 이미지를 완전히 제어할 수 있다.
  * 롤백
    * 현재의 이미지 반복이 적절하지 않은 경우 이전 버전으로 롤백 가능
  * 신속한 배포
    * Docker 기반 컨테이너는 배포 시간을 몇 초로 단축가능
    * 각 프로세스에 대한 컨테이너를 생성함으로써 사용자는 유사한 프로세스를 새 앱과 빠르게 공유가능
    * 컨테이너를 추가하거나 이동하기 위해 OS를 부팅할 필요가 없으므로 배포 시간이 크게 단축
    * 배포 속도가 빨라 컨테이너에서 생성된 데이터를 비용 효율적으로 쉽게 생성하고 삭제할 수 있다.
    
